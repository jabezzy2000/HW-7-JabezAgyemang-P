## Tracing

Where can we find your tracing solutions?

**Beneath the solutions**

## Time/Space Complexity
State the time and space complexity for one solution of each problem, explaining your reasoning.

**Beneath the solutions as well**

## Reflections

Answer each of these questions *FOR EACH PROBLEM*.

What resources did you use to solve this problems? Include collaborators, TAs, office hours, online resources, etc. Were any particularly helpful?

**For invert and is_univalued, It was a bit easy to come up with an intuitive approach. for range count, I was finding it hard to pass the count through every recursive call and after passing it by Tyler, I had an idea to maybe try it without the helper function and just re-call the main function itself every time **

What was your thought process when coming up with this solution? Was any example problem particularly helpful?

**From the examples we worked in class, i think i got a good grasp on how tree questions generally went so for each question, I was able to easily come up with an idea of how the code should look and how each recursive call should look like. **

Describe any failed approaches or any bugs that you had in your original implementation, and how you debugged them. If you got it perfect on your first try, that's okay too.

**For range_count, I had a helper function and tried to return 1 whenever the value was within bounds but returning ended the function. I also tried incrementing the count function in the helper functions with count being a global variable but I remembered during one of my mock interviews, I learned it wasn't a really good idea.**

What test cases helped you verify that your solution is correct? Describe the inputs and expected outputs.

**for each question, i created tree nodes and linked them to form a sample tree to test out the code before and after they were run. Each test code is still included in their respective function files.**